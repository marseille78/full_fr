boolean --- Примітивний тип даних, який представляє два можливі логічні значення: *true* (істина) або *false* (хибність).



number --- Примітивний тип даних, який використовується для представлення числових значень, включаючи цілі числа, числа з плаваючою комою, а також спеціальні значення, такі як *NaN* та *Infinity*.



string --- Примітивний тип даних, який використовується для представлення текстових значень, тобто послідовностей символів, записаних у лапках.



null --- Примітивний тип даних, який представляє відсутність значення або явну порожнечу. Він має одне значення, яке вказує, що змінна не має жодного об'єкта чи значення.



undefined --- Примітивний тип даних, який представляє значення "не визначено". Він має одне значення, що вказує, що змінна була оголошена, але їй не присвоєно жодного значення.



any --- Універсальний тип даних, який дозволяє змінній приймати значення *будь-якого типу* без перевірки типів під час компіляції. Використання цього типу фактично відключає систему типізації TypeScript для цієї змінної.



unknown --- Тип даних, який використовується для значень, тип яких невідомий під час компіляції. Він є більш безпечним аналогом типу *any*, оскільки не дозволяє виконувати операції з даними без попередньої перевірки їх типу.



string[] --- Масив, елементами якого є значення типу *string*. Це означає, що всі елементи масиву мають бути рядками.



Array<number> --- Масив, елементами якого є значення типу *number*. Це альтернативний запис типу масиву чисел, еквівалентний *number[]*.



type User = {
  name: string;
  age?: number;
  action: (role: string) => void;
} --- Пользовательський тип *User* (alias), який описує об'єкт із двома властивостями:

– властивість *name*, що має значення типу *string*.
– необов'язкова властивість *age*, що має значення типу *number*.
– метод *action*, що приймає аргумент *role* типу *string* і нічого не повертає.



type Goods = {
  [key: string]: number;
}; --- Конструкція, що визначає об'єктний тип *Goods* зі змінними ключами та значеннями.

Структура об'єкта:

- це індексний підпис, який означає:

Ключі (властивості) *key* об'єкта можуть мати будь-яке ім'я, але воно має бути рядковим типом (*string*).
Цей підпис дозволяє створювати об'єкти з динамічними властивостями.

*number* — це тип значень, які будуть відповідати кожному ключу. У цьому випадку всі значення повинні бути числами.

Особливість:

Індексний підпис дозволяє створювати типи для об'єктів зі змінною кількістю властивостей, коли їхні імена наперед невідомі, але тип значень однаковий.



enum Sizes {
  SMALL = 'small',
  MEDIUM = 'medium',
  LARGE = 'large',
}; --- Це спосіб створення переліків іменованих констант для роботи з чітко визначеним набором значень. Це робить код зрозумілішим, типізованим і легшим у підтримці.

Ця конструкція визначає конструкцію *Sizes*, який представляє набір іменованих констант із певними значеннями типу string.

*Опис властивостей:*

*Sizes.SMALL* – має значення *'small'*.
*Sizes.MEDIUM* – має значення *'medium'*.
*Sizes.LARGE* – має значення *'large'*.



const enum HttpCodes {
  OK = 200,
  BadRequest = 400,
  Unauthorized = 401,
} --- Ця конструкція в TypeScript визначає *HttpCodes*, який використовується для зберігання групи пов'язаних констант, що представляють статуси HTTP.
Це константний перерахунок, який TypeScript повністю видаляє під час компіляції. Значення замінюються безпосередньо на їхні числові або рядкові еквіваленти.
Використовується для оптимізації, щоб уникнути додаткового коду, пов'язаного зі звичайними перерахунками.

Назва перерахунку: *HttpCodes*

Члени перерахунку:

*OK*: *200* — відповідає статусу HTTP 200 (успішний запит).
*BadRequest*: *400* — відповідає статусу HTTP 400 (помилка клієнта).
*Unauthorized*: *401* — відповідає статусу HTTP 401 (неавторизований доступ).

Значення можуть бути числами, рядками або обчислюваними значеннями.



function add(num1: number, num2: number): string {
  ... 
} --- Функція *add*, яка приймає два аргументи типу number та повертає значення типу string.

Параметри:

*num1*: перший параметр, який повинен бути числового типу.
*num2*: другий параметр, також числового типу.
Аргументи num1 і num2 є обов'язковими.

Тип поверненого значення: *рядок*.

Тіло функції: *{ ... }* реалізується логіка, яка виконує певні дії, і повертає рядок.



function add(num1: number, num2: number): void {
  ...
} --- Функція *add*, яка приймає два аргументи типу *number* і *не повертає значення*.

Параметри:

*num1*: перший параметр, який повинен бути числового типу.
*num2*: другий параметр, також числового типу.
Аргументи *num1* і *num2* є обов'язковими, якщо не вказано інакше (наприклад, через ? для необов'язкових параметрів).

Тип поверненого значення: *функція нічого не повертає*.

Тіло функції: *{ ... }* реалізується логіка, яка виконує певні дії, але не повертає результат.



===============================
function identity<T>(arg: T): T {
  return arg;
} --- Універсальна (generic) функція *identity*, яка приймає аргумент будь-якого типу *T* і повертає значення того ж типу.

Універсальний параметр:

*T* — це generic (універсальний параметр типу), який дозволяє функції працювати з будь-яким типом, визначеним у момент її виклику.

Параметри:

*arg* — це параметр функції

Тіло функції:

*return arg;* — функція просто повертає те, що отримала як аргумент.



function lengthOfObject<T extends { length: number }>(obj: T): number {
  return obj.length;
} --- Універсальна (generic) функція *lengthOfObject*, яка приймає об'єкт *obj* із властивістю *length* і повертає *числове значення* цієї властивості.

*lengthOfObject* — назва функції, яку можна викликати для отримання довжини об'єкта.
*T* — це універсальний параметр, який означає, що функція працює з будь-яким типом.
*obj* — параметр функції.

Тип *T* повинен бути об'єктом, який містить властивість *length* типу *number*.

Це гарантує, що об'єкт, переданий у функцію, матиме властивість *length*.

Тип повернення - *number*

Тіло функції - *return obj.length;*



function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
} --- Універсальна (generic) функція *getProperty* в TypeScript, яка дозволяє динамічно отримати значення властивості об'єкта з безпечною типізацією.

*getProperty* — назва функції, яка повертає значення властивості об'єкта.

*T* — універсальний тип, що представляє тип об'єкта *obj*.
*K* — це ключ об'єкта *T*.
Обмеження гарантує, що *K* буде одним із ключів об'єкта *T*.
*obj* - Об'єкт, з якого буде отримано значення властивості.
Тип *T* описує структуру цього об'єкта.
*K* - Ключ властивості, значення якої потрібно отримати.
Тип *K* гарантує, що цей ключ є дійсною властивістю об'єкта obj.

Значення типу властивості, яка відповідає ключу key у переданому об'єкті obj.

Тіло функції - return obj[key];

Функція повертає значення властивості об'єкта *obj* з ключем *key*.



function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>): Todo {
  return { ...todo, ...fieldsToUpdate };
} --- Функція *updateTodo* для оновлення об'єкта типу *Todo*.

Аргументи:

- *todo*: об'єкт типу *Todo*, який потрібно оновити.
- *fieldsToUpdate*: об'єкт, що містить лише ті поля, які потрібно змінити. 

Повертає:

- Новий об'єкт типу *Todo*, що є поєднанням полів вихідного об'єкта *todo* та оновлень із *fieldsToUpdate*.

Тіло функції:

- Оператор розпакування *return { ...todo, ...fieldsToUpdate };*, що об'єднує властивості двох об'єктів



const john: Readonly<User> = {
  name: "John",
  age: 30,
}; --- Опиши об'єкт за наступними даними:

1. Оголошення змінної:

- Змінна *const john* оголошується як константа, тому її значення не можна перевизначити.

2. Тип змінної:

- Тип змінної *john* визначено як модифікована версія типу *User*, яка додає обмеження на зміну властивостей об'єкта.

3. Назва типу:

- Об'єкт повинен відповідати типу *User*. Тип *User* описує структуру, яка має:
- Властивість *name* типу *string*.
- Властивість *age* типу *number*.

4. Обмеження на властивості:

- Всі властивості об'єкта стають доступними лише для читання. Це означає, що їх значення не можна змінити, видалити або перевизначити після створення об'єкта.

5. Вміст об'єкта:

- Об'єкт має такі значення:
- *name: "John"*.
- *age: 30*.

6. Призначення обмеження:

- Забезпечує, що об'єкт, створений на основі типу *User*, залишатиметься незмінним протягом усього часу використання.



type PersonSummary = Pick<Person, "name" | "age">; --- Опиши тип *PersonSummary* за наступними даними:

1. Створення нового типу:

- Оголошується новий тип *PersonSummary*, який є частковою версією типу *Person*.

2. Тип джерела:

- Тип *Person* описує структуру об'єкта, який містить кілька властивостей, наприклад, *name*, *age*, *address*, *phoneNumber*, тощо.

3. Новий тип:

- Тип *PersonSummary* включає лише дві властивості з типу *Person*:
- *name*.
- *age*.

4. Механізм вибору властивостей:

- Забезпечується вибір лише конкретних властивостей із типу *Person*, у цьому випадку *name* і *age*.

5. Результат застосування:

- Створюється тип, що містить підмножину властивостей оригінального типу *Person*.

6. Призначення механізму:

- Полегшує створення типів, які містять лише потрібні властивості, забезпечуючи зручність і уникнення дублювання коду.



type PersonWithoutAddress = Omit<Person, "address">; --- Опиши тип *PersonWithoutAddress* за наступними даними:

1. Створення нового типу:

- Оголошується новий тип *PersonWithoutAddress*, який базується на типі *Person*.

2. Тип джерела:

- Тип *Person* описує структуру об'єкта, який містить кілька властивостей, наприклад, *name*, *age*, *address*, *phoneNumber*, тощо.

3. Новий тип:

- Тип *PersonWithoutAddress* містить усі властивості типу *Person*, крім однієї — *address*.

4. Механізм виключення властивостей:

- Створюється тип, у якому виключено зазначену властивість (*address*) з оригінального типу.

5. Результат застосування:

- У новому типі залишаються тільки ті властивості типу *Person*, які явно не вказані для виключення.

6. Призначення механізму:

- Полегшує створення типів, які виключають непотрібні властивості, забезпечуючи більш чітке визначення структури об'єкта.



type CityDatabase = Record<string, number>; --- 1. Створіть тип *CityDatabase*:

- Він має описувати об'єкт, де ключами є рядки, а значеннями — числа.

2. Обмежте тип ключів об'єкта:

- Необхідно визначити тип, який базується на *CityDatabase*, але виключає певний ключ або групу ключів, які будуть вказані явно.

3. Очікувана функціональність:

- Створений тип дозволить виключити небажані ключі з початкового типу, забезпечуючи гнучкість і чіткість структури об'єкта.

4. Механізм, який слід використовувати:

- Визначте тип, що дозволяє відфільтрувати певні ключі з існуючого типу, створюючи новий тип без змінюваних елементів.

Результат: Тип, який динамічно виключає задані ключі зі структури *CityDatabase*.



function getPromise(): Promise<(string | number)[]> {
  return new Promise<(string | number)[]>((resolve) => {
    resolve(["Text", 50]);
  });
} --- Створіть функцію *getPromise*:

- Функція повинна бути оголошена з назвою *getPromise*.

1. Тип повернення:

- Функція має повертати об'єкт типу *Promise*.
- Тип значення, яке повертає обіцянка, — це масив, що містить елементи двох типів:
- *string*.
- *number*.

2. Реалізація функції:

- Усередині функції потрібно створити новий об'єкт типу *Promise*.
- При створенні обіцянки використовуйте функцію з одним параметром *resolve* і тілом функції *resolve(["Text", 50]);*

3. Значення обіцянки:

- Обіцянка має вирішуватися з масивом, де перший елемент — рядок, а другий — число.
- Масив повинен відповідати типу *(string | number)[]*.

4. **Мета завдання**:

- Забезпечити строгий контроль типів, гарантувати, що функція повертає правильно типізовану обіцянку.